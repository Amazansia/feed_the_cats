7
3 6 2 >빠지고
7 3 2 >빠지고
4 2 0
1 4 0
5 7 6 >빠지고
2 5 1 >빠지고
6 1 0

12 10 9 빼고
2 5 빠짐
남은 사람 셋...
이렇게는 안될거같은데

4 2를 보면
3 6
2 5
1 4


하나하나 다 세봐?
좀 귀찮지 않나...백퍼 시간초과 날 것 같은데
최소 10만번 돌아야 함...
해봅시당
자기보다 둘 다 낮은 친구들을 싹 세어야 함, 그럼 자기가 빠지면 이 친구들이 살아남는 구조
>> (살아남는 친구들의 수) = (전체) - (자기보다 둘 다 낮은 친구들의 수)를 구한다
>> 자기보다 둘 다 낮은 친구들의 수가 0인 친구들을 세면 될 듯?

>> 즉 자기보다 둘 다 낮은 친구들이 있는 애들의 개수를 세서 빼면 될 듯 하다
정렬 필요함
순서 변경되어도 상관없음, 그러나 쌍은 변경되면 안 됨
메모리가 모자르지는 않을 것 같은데 자료구조 두 개 써도 되지 않을까?
TreeMap이 빠르다고는 했는데 데이터가 Hash Collision이 일어날 것 같지는 않다(순번이니까)
근데 굳이 따로 sort할 필요가 있지는...않을 것 같음
그냥 TreeMap 써보는 것으로
testScore, interviewScore 맵 하나씩 만들어서
<성적, 번호> 순으로
키값 순으로 정렬시키고
testScoreMap으로 얘보다 낮은 애들 중 interviewScoreMap의 인덱스도 낮은 애들이 존재하는 친구는 무조건 거르면 됨.
이렇게 N번만큼 돌게 될 듯?



https://devmoony.tistory.com/95
map의 key&value값 기준 정렬 방법...굳이? 느릴듯

Collections.sort가 빠르댔다




<test, interview>
3 6
7 3
4 2
1 4
5 7
2 5
6 1


test_interviewMap
7 3
6 1
5 7
4 2
3 6
2 5
1 4

4 2를 기준으로 하면, 4 밑의 엔트리 중 value가 2보다 작은 애들이 존재하면 빠져야 함
3 6
2 1
1 4
6 1 4의 min값인 1이 기준값인 2보다 작으면 count++;



testScoreMap
<성적, 번호>
7 1
6 6
5 4
4 2
3 0
2 5
1 3

interviewScoreMap
<성적, 번호>
7 4
6 0
5 5
4 3
3 1
2 2
1 6


맵에는 위와 같이 저장됨
그럼 iter로 접근한다고 했을 때, testScoreMap에서 제일 위에 있는 친구를 접근한다고 해 보자. 7 1 얘.


Integer key: testScoreMap.keySet()-> 얘가 기준 성적이 됨.
그러면 testScoreMap.get(key) 해서 번호를 가져올 수 있지.
그럼 interviewScoreMap에서 getValue(testScoreMap.get(key))를 하면 해당 엔트리가 나온다.
해당 엔트리 밑에
6 4 2 0 5 3 이 번호가 있으면 안됨


3 2
1 4
4 1
2 3
5 5

5 5
4 1
3 2
2 3
1 4

문제 바보같이 읽어서
바보같이 몇시간 붙들고
바보같이 울고...